# Задачи 06.01.2023

## Задача 1
Да се реализира сортировката CoctailShaker, която е много подобна на BubbleSort.

Алгоритъмът е следния:
Проверяваме първия и втория елемент. Ако първия е по - голям от втория **ги разместваме**. След товва проверяваме втория и третия и правим същото. Стъпката се изпълнява докато не стигнем до края на колекцията. Щом стигнем до края на колекцията **най - големия елемент е на мястото си** т.е. няма нужда  да го пипаме. 

Сега тръгваме наобратно и сравняваме **предпоследния с предпредпоследния**. Ако предпоследния е по - малък ги разменяме. Прилагаме подобна на първоначалната стратегия докато най - малкия елемент не заеме мястото си. 

След това започваме пак отначало. Този път сравняваме втория и третия.

Процедярата се повтаря в двете посоки, докато масивът не се сортира.

[Визуализатор](https://www.sortvisualizer.com/shakersort/).

### Пример:
    
    Вход: [4, 1, 2, 8, 9, 15, -4, 0, -6, 11, 3]
    1во -> 
          [4, 1, 2, 8, 9, -4, 0, -6, 11, 3, 15]
    2ро <-
          [-6, 4, 1, 2, 8, 9, -4, 0, 11, 3, 15]


## Задача 2
Да се напише функция, която приема двумерен масив arr[3][N] от числа. 

arr[0] наричаме първичен ключ.
arr[1] наричаме вторичен ключ.
arr[2] наричаме стойност.

Тройката (arr[0][i], arr[1][i], arr[2][i]) е по - малка от тройката (arr[0][j], arr[1][j], arr[2][j]) ако

```
arr[0][i] < arr[0][j] или arr[0][i] == arr[0][j] & arr[1][i] < arr[1][j]. 
```

Сортирайте двумерния масив така, че за всяко i < j е вярно (arr[0][i], arr[1][i], arr[2][i]) < (arr[0][j], arr[1][j], arr[2][j]).

```Пример
[ 
      [4 7 4 9 4 12],
      [2 4 1 5 3 0],
      [1 2 3 4 5 6]
]

[
      [4 4 4 7 9 12],
      [1 2 3 4 5 0],
      [3 1 5 2 4 6]
]
```        
## Задача трета
Разглеждаме функция int findIndex(int* arr, int* arrSecond, size_t arrLenght). За arr знаем, че е сортиран и е от числа по - големи от 0. arrSecond е същия като arr само, че някъде са му добавили елемента -1.

```
Примерно:
arr = [1, 2, 4, 8, 16, 32, 64, 128]
arrSecond = [1, 2, 4, 8, -1, 16, 32, 64, 128]
arrLength = 8
```
Дължината на втория масив не е дадена, понеже е лесно да се намери.

Функцията трябва да връща на кой индекс се намираа -1. 

Очаква се функцията да работи ефикасно върху големи масиви.

## Задача четвърта
Да се напише функция, която намира колко инверсии има в масив от цели числа.

```
Инверсия

Всяка двойка (i, j) за която i < j и arr[i] > arr[j].
```
